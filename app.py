import streamlit as st
import pandas as pd
import pickle

# ---- Load data ----
@st.cache_data
def load_data():
    with open("exam_ui_data.pkl", "rb") as f:
        ui_data = pickle.load(f)
    schedule = ui_data["schedule"]                 # dict: course -> slot
    student_courses = ui_data["student_courses"]   # dict: student -> [courses]
    slot_info = ui_data["slot_info"]               # dict: slot -> (day, session)
    schedule_df = ui_data["schedule_df"]           # DataFrame
    num_days = ui_data.get("NUM_DAYS", 10)
    sessions_per_day = ui_data.get("SESSIONS_PER_DAY", 4)
    max_exams_per_day = ui_data.get("MAX_EXAMS_PER_DAY", 2)
    return schedule, student_courses, slot_info, schedule_df, num_days, sessions_per_day, max_exams_per_day

schedule, student_courses, slot_info, schedule_df, NUM_DAYS, SESSIONS_PER_DAY, MAX_EXAMS_PER_DAY = load_data()

# ---- Sidebar: project description ----
st.sidebar.title("About this demo")
st.sidebar.markdown(
    """
    This app visualizes an exam timetable generated by a constraint optimization model
    built with **Google OR-Tools**.

    It uses real enrollment-style data (~1000 students, ~100 courses) and ensures:
    - Each course has exactly one exam slot.
    - No student has overlapping exams.
    - Each student has at most **"""
    + str(MAX_EXAMS_PER_DAY)
    + """ exam(s) per day**.
    """
)

st.sidebar.subheader("Instance details")
st.sidebar.write(f"Students: `{len(student_courses)}`")
st.sidebar.write(f"Courses: `{schedule_df['course'].nunique()}`")
st.sidebar.write(f"Days: `{NUM_DAYS}`")
st.sidebar.write(f"Slots per day: `{SESSIONS_PER_DAY}`")

# ---- Page title ----
st.title("Exam Scheduler Demo")

st.markdown(
    """
    This is a prototype exam scheduling system. The timetable below is **clash-free**
    and respects a per-student daily exam limit.
    """
)

# ---- Global timetable view ----
st.header("Global Exam Timetable")

st.dataframe(
    schedule_df.sort_values(["day", "session", "course"]).reset_index(drop=True),
    use_container_width=True,
)

# ---- Per-student view ----
st.header("View a Student's Personalized Schedule")

student_ids = sorted(student_courses.keys())
selected_student = st.selectbox("Select student ID", student_ids)

enrolled_courses = student_courses[selected_student]

rows = []
for c in enrolled_courses:
    slot = schedule[c]
    day, session = slot_info[slot]
    rows.append({
        "course": c,
        "day": day,
        "session": session,
        "slot": slot,
    })

student_df = pd.DataFrame(rows).sort_values(["day", "slot"])

st.subheader(f"Schedule for student `{selected_student}`")
st.dataframe(student_df.reset_index(drop=True), use_container_width=True)

# ---- Fairness & load summary ----
st.header("Fairness & Load Summary")

per_student_max_day_load = []
exam_spans = []
exam_days_counts = []

for s, courses in student_courses.items():
    days = []
    day_counts = {}

    for c in courses:
        slot = schedule[c]
        day, _ = slot_info[slot]
        days.append(day)
        day_counts[day] = day_counts.get(day, 0) + 1

    days_sorted = sorted(set(days))
    exam_days_counts.append(len(days_sorted))
    exam_spans.append(days_sorted[-1] - days_sorted[0])  # span from first to last exam day
    per_student_max_day_load.append(max(day_counts.values()))

max_exams_any_day = max(per_student_max_day_load)
avg_max_exams = sum(per_student_max_day_load) / len(per_student_max_day_load)
avg_span = sum(exam_spans) / len(exam_spans)
avg_exam_days = sum(exam_days_counts) / len(exam_days_counts)

col1, col2, col3 = st.columns(3)
with col1:
    st.metric(
        "Max exams in any day (any student)",
        max_exams_any_day,
        help="Highest number of exams a single student has in one day."
    )
with col2:
    st.metric(
        "Avg of [max exams/day per student]",
        round(avg_max_exams, 2),
        help="For each student, take their busiest exam day; this is the average of that."
    )
with col3:
    st.metric(
        "Avg exam span per student (days)",
        round(avg_span, 2),
        help="Average distance from first to last exam day per student."
    )

st.metric(
    "Avg number of exam days per student",
    round(avg_exam_days, 2),
    help="On how many distinct days students typically have exams."
)

st.subheader("Exams per day (global)")
exams_per_day = schedule_df.groupby("day")["course"].count()
st.bar_chart(exams_per_day)